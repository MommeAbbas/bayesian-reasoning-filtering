import numpy as np


def logistic(x):
    return 1.0 / (1.0 + np.exp(-x))


class OnlineCorrectnessPredictor:
    """
    Maps a belief over latent state x_k to a probability
    P(final answer is correct | y_{1:k}).

    This class is intentionally simple and explicit.
    """

    def __init__(self, w=None, b=0.0):
        """
        w: weight vector mapping latent state -> correctness logit
           default emphasizes progress and coherence, penalizes uncertainty
        b: bias term
        """
        if w is None:
            # [progress, coherence, uncertainty]
            self.w = np.array([2.0, 1.5, -2.0], dtype=float)
        else:
            self.w = np.asarray(w, dtype=float)

        self.b = float(b)

    def prob_correct_from_state(self, x):
        """
        x: latent state vector (3,)
        returns scalar probability in (0,1)
        """
        logit = self.w @ x + self.b
        return logistic(logit)

    def prob_correct_from_particles(self, mus, weights):
        """
        mus: array of shape (N, 3) of particle means
        weights: array of shape (N,) summing to 1

        Returns:
          E_{p(x|y)} [ P(correct | x) ]
        """
        probs = np.array(
            [self.prob_correct_from_state(mu) for mu in mus],
            dtype=float,
        )
        return float(np.sum(weights * probs))


class OnlinePredictionRecorder:
    """
    Stores predictions over time for a single trajectory.
    """

    def __init__(self):
        self.p_hats = []

    def update(self, p_hat):
        self.p_hats.append(float(p_hat))

    def as_array(self):
        return np.array(self.p_hats, dtype=float)
